启动一个wsgi-server, Proxy，--(ring)--(http_connect)》account, container, object,
=====================================================
1,
    proxyr/server.py
    168行的eventlet.posthooks()
    是什么用？在此之前在什么时候，在什么地方会设置env[‘eventlet.posthooks']
    这个应该是wsgi-server设置的，如果支持这个参数的话，
    就会在完全发送一个response后执行posthooks,
    如果不支持这个参数的话，就不能记录请求的发送量

    http://eventlet.net/doc/modules/wsgi.html

    Non-Standard Extension to Support Post Hooks¶
    Eventlet’s WSGI server supports a non-standard extension to the WSGI
    specification where env['eventlet.posthooks'] contains an array of post
    hooks that will be called after fully sending a response. Each post hook
    is a tuple of (func, args, kwargs) and the func will be called with the
    WSGI environment dictionary, followed by the args and then the kwargs in
    the post hook.

    For example:

    from eventlet import wsgi
    import eventlet

    def hook(env, arg1, arg2, kwarg3=None, kwarg4=None):
        print 'Hook called: %s %s %s %s %s' % (env, arg1, arg2, kwarg3,
                                               kwarg4)

        def hello_world(env, start_response):
            env['eventlet.posthooks'].append(
                                             (hook, ('arg1',
                                                     'arg2'),
                                              {'kwarg3': 3,
                                              'kwarg4': 4}))
            start_response('200 OK', [('Content-Type',
                                       'text/plain')])
            return ['Hello, World!\r\n']

            wsgi.server(eventlet.listen(('', 8090)),
                        hello_world)

            The above code will print the WSGI environment and
            the other passed function arguments for every
            request processed.

            Post hooks are useful when code needs to be
            executed after a response has been fully sent to
            the client (or when the client disconnects early).
            One example is for more accurate logging of
            bandwidth used, as client disconnects use less
            bandwidth than the actual Content-Length.


------------------------------------------------------------
2,

    在AccountC里面，x-account-meta 在此之前在什么时候设置的？如果没有
    设置的话，执行到这里就会自动退出？

    这个是个傻冒问题，哈哈，在没有的情况下，check_meta返回的是None，Account
    的put是不会退出的。

    ??????????
3，
    account_partition, accounts =
self.app.account_ring.get_nodes(self.account_name)
    到这里开始看ring的计算方法，

4,
    为什么选用2的次方来做韦partition,
    在创建ring时，分两种情况，第一种是存在了objct.build
    ，另一种是不存在objct.build，分别怎么处理?

5,
 RingBuilder(18, 3, 1)

































    6, reblance后，怎么找到之前的位置


    7,
    how to understand this ?
    Various hashing algorithms were tried. SHA offers better security, but the
    ring doesn’t need to be cryptographically secure and SHA is slower. Murmur
    was much faster, but MD5 was built-in and hash computation is a small
    percentage of the overall request handling time. In all, once it was
    decided the servers wouldn’t be maintaining the rings themselves anyway
    and only doing hash lookups, MD5 was chosen for its general availability,
    good distribution, and adequate speed.




    8,
    今日写了一个wsgi-server

    9,
    from eventlet import timeout
    可以使用with timeout，

    10,
    看了eventlet，看了用eventlet来实现的一个简单的端口转发，

    11,
    common/db.py --182
    how to understand ''
    conn = sqlite3.connect(tmp_db_file, check_same_thread=False,
                           factory=GreenDBConnection, timeout=0)

    >>> print sqlite3.connect.__doc__
    connect(database[, timeout, isolation_level, detect_types, factory])

    Opens a connection to the SQLite database file *database*. You can use
    ":memory:" to open a database connection to a database that resides in
    RAM instead of on disk.
    >>>
    从上面这点用法里面可以看到，他没有check_same_thread的参赛，
    timeout=0, 为什么要设置为0?

    factory:
    By default, the sqlite3 module uses its Connection class for the connect
    call. You can, however, subclass the Connection class and make connect()
    use your class instead by providing your class for the factory parameter.

    GreenDBConnection是自定义的一个connection，但不知用意为何？

    12,
    一个account里面多少个container，一个container里面多少个Objgect最优

    13,
    swift能动态调整保存的份数，
    好像不能。

    14，
    在swift/trunk/swift/proxy/server.py
    里面，395行，是不是可能存在访问一个没有定义过的变量cache_key?

    不会，看错了，:),这句之前，先判断了下是否有memcache..

    15,
    memcache缓存了一个数据信息，比如container_info, account_info,
